---
title: "Predictors"
author: "Andres N. Rosales"
date: "2024-11-11"
output:
  html_document:
    highlight: espresso
    toc: yes
    theme: sandstone
  pdf_document:
    toc: yes
  word_document:
    toc: yes
---

This code creates spatial buffers using the 'sf' package and calcualtes 
metrics using the 'landscape metrics package'.

# Library
```{r}

library(dplyr)
library(purrr)
library(ggplot2)
library(rnaturalearth)
library(sf)
library(raster)
library(terra)
library(tinytex)
library(rmarkdown)
library(knitr)
library(ebirdst)
library(exactextractr)
library(landscapemetrics)
library(readr)
library(stringr)
library(tidyr)
library(units)
library(viridis)
library(progress)
library(dplyr)

```

# PHJV 
## Load Spatial Buffer
```{r}
#Load PHJV buffers we made in the ebirdst.rmd file
phjv_buff <- st_read("Predictor_buffer/utrd_buff_PHJV.gpkg", layer = "ubuffPHJV") #shapefile should be in WGS43


```

Calculate annual abundance

$Ay = A2017 Ã— (1 + r)^{y-2017}$

- Ay is the abundance in year y.
- A2017  is the abundance in 2017 (median year).
- r is the annual percent change expressed as a decimal.
- y is the year of interest.

```{r}
#annual abundance estimates
phjv_buff <- phjv_buff %>%
  bind_cols(map_dfc(2012:2022, 
                    ~ tibble(!!paste0( .x) := phjv_buff$abd * 
                               (1 + phjv_buff$abd_ppy) ^ (.x - 2017))))
#remove abd column since this is only the abd for the median year
phjv_buff <- phjv_buff[, -c(4)]


```


Subset estimates with >80% confidence
```{r}
phjv_buff <- subset(phjv_buff, abd_ppy_no == "TRUE")

```

Visualize Buffers
```{r}

ggplot() +
  geom_sf(data = phjv_buff, fill = "lightgreen", color = "darkgreen", alpha = 0.5) +
  theme_minimal() +
  labs(title = "13.5 km Circular Buffers", x = "Longitude", y = "Latitude")
op <- options_landscapemetrics()

```






---

## Composition Rasters
Load Canada rasters classified for composition and configuration metrics. These rasters are classified by 17 simple land cover classifications.
```{r}
can_rasters <- list(
  "2012" = rast("C:/Users/Andres/OneDrive - University of Saskatchewan/04_landcover/04_predictor_code/Canada_comp/2012.tif"),
  "2013" = rast("C:/Users/Andres/OneDrive - University of Saskatchewan/04_landcover/04_predictor_code/Canada_comp/2013.tif"),
  "2014" = rast("C:/Users/Andres/OneDrive - University of Saskatchewan/04_landcover/04_predictor_code/Canada_comp/2014.tif"),
  "2015" = rast("C:/Users/Andres/OneDrive - University of Saskatchewan/04_landcover/04_predictor_code/Canada_comp/2015.tif"),
  "2016" = rast("C:/Users/Andres/OneDrive - University of Saskatchewan/04_landcover/04_predictor_code/Canada_comp/2016.tif"),
  "2017" = rast("C:/Users/Andres/OneDrive - University of Saskatchewan/04_landcover/04_predictor_code/Canada_comp/2017.tif"),
  "2018" = rast("C:/Users/Andres/OneDrive - University of Saskatchewan/04_landcover/04_predictor_code/Canada_comp/2018.tif"),
  "2019" = rast("C:/Users/Andres/OneDrive - University of Saskatchewan/04_landcover/04_predictor_code/Canada_comp/2019.tif"),
  "2020" = rast("C:/Users/Andres/OneDrive - University of Saskatchewan/04_landcover/04_predictor_code/Canada_comp/2020.tif"),
  "2021" = rast("C:/Users/Andres/OneDrive - University of Saskatchewan/04_landcover/04_predictor_code/Canada_comp/2021.tif"),
  "2022" = rast("C:/Users/Andres/OneDrive - University of Saskatchewan/04_landcover/04_predictor_code/Canada_comp/2022.tif")
)

```


Create table of all classifications and their respective labels
```{r}
lc_classes <- data.frame(
  class = 1:17,
  label = c("Cereal", "Pulses", "Canola", "Soybean", "Oilseed", "Potatoes", 
            "Berries", "Fruits and Vegetables", "Forage", "Other Ag", 
            "Grassland", "Shrubland", "Wetland", "Forested", "Barren", 
            "Urban", "Water"),
  stringsAsFactors = FALSE)

lc_classes
```


Run landscape metrics for landscapes within each estimate buffer. 
Two metrics calculated at the class level: "pland" - Proportions of each land cover type and "lpi" - large patch index.
Four metrics at the landscape level: "SHDI" - Shannon diversity index, "ed" - Edge density, "pd" - Patch density, "ai" - aggregation index, "Cohesion" - Patch cohesion index
```{r}

# Initialize an empty list to store results
lsm_comp <- list()

# Loop through each year and buffer, this will result in a very large list. Takes ~6 hours to run
for (year in names(can_rasters)) {
  for (i in seq_len(nrow(phjv_buff))) {
    # Transform the buffer to match the raster's CRS
    buffer_i <- st_transform(phjv_buff[i, ], crs = crs(can_rasters[[year]]))
    
    # Crop and mask the landcover raster for the current year
    class_metrics <- crop(can_rasters[[year]], buffer_i) |> 
      mask(buffer_i) |> 
      # Calculate class-level metrics
      calculate_lsm(level = "class", metric = c("pland","lpi")) |> 
      # Add variables to uniquely identify each point and year
      mutate(srd_id = buffer_i$srd_id, year = as.integer(year))
    
    landscape_metrics <- crop(can_rasters[[year]], buffer_i) |> 
      mask(buffer_i) |> 
      # Calculate landscape-level metrics
      calculate_lsm(level = "landscape", metric = c("shdi", "ed", "pd", "ai", "cohesion")) |> 
      # Add variables to uniquely identify each point and year
      mutate(srd_id = buffer_i$srd_id, year = as.integer(year))
    
    # Combine class-level and landscape-level metrics
    lsm_comp[[paste(year, i, sep = "_")]] <- bind_rows(class_metrics, landscape_metrics) |> 
      dplyr::select(year, srd_id, class, metric, value)
  }
}

# Combine results into a single data frame
lsm_comp <- bind_rows(lsm_pg)

#save as RDS
saveRDS(lsm_comp, "Data/phjv_lsm_long.rds")


```

Transform data to wide format.
```{r}

# Updated code to transform to wide format
phjv_lsm_comp <- lsm_comp |> 
  # Fill missing combinations with zeros
  complete(
    year,                        # Include all years
    srd_id,                      # Ensure all buffers are represented
    class = unique(lc_classes$class), # Ensure all classes are included
    metric = c("pland", "lpi"), # Include all metrics
    fill = list(value = 0)       # Fill missing values with zeros
  ) |> 
  # Join with descriptive class labels
  left_join(dplyr::select(lc_classes, class, label), by = "class") |> 
  # Transform to wide format
  pivot_wider(
    values_from = value,                          # Metric values to populate wide-format table
    names_from = c(class, label, metric),   # Columns formed by year, class, label, and metric
    names_glue = "{metric}_c{str_pad(class, 2, pad = '0')}_{label}", # Format names
    names_sort = TRUE,                            # Ensure logical sorting of columns
    values_fill = 0                               # Fill missing combinations with zeros
  ) |> 
  arrange(srd_id)                           # Sort rows by year and buffer ID

```

Save output landscape metrics
```{r}
#save as RDS
saveRDS(phjv_lsm_comp, "Data/phjv_lsm.rds")

#save a CSV 
write.csv(phjv_lsm_comp, "Data/phjv_lsm.csv", row.names = FALSE)

```


## Landscape Simplification metrics

```{r}

can_simp_rasters <- list(
  "2012" = rast("C:/Users/Andres/OneDrive - University of Saskatchewan/04_landcover/05_Simplification/Canada/Can_simp_12.tif"),
  "2013" = rast("C:/Users/Andres/OneDrive - University of Saskatchewan/04_landcover/05_Simplification/Canada/can_simp_13.tif"),
  "2014" = rast("C:/Users/Andres/OneDrive - University of Saskatchewan/04_landcover/05_Simplification/Canada/can_simp_14.tif"),
  "2015" = rast("C:/Users/Andres/OneDrive - University of Saskatchewan/04_landcover/05_Simplification/Canada/can_simp_15.tif"),
  "2016" = rast("C:/Users/Andres/OneDrive - University of Saskatchewan/04_landcover/05_Simplification/Canada/can_simp_16.tif"),
  "2017" = rast("C:/Users/Andres/OneDrive - University of Saskatchewan/04_landcover/05_Simplification/Canada/can_simp_17.tif"),
  "2018" = rast("C:/Users/Andres/OneDrive - University of Saskatchewan/04_landcover/05_Simplification/Canada/can_simp_18.tif"),
  "2019" = rast("C:/Users/Andres/OneDrive - University of Saskatchewan/04_landcover/05_Simplification/Canada/can_simp_19.tif"),
  "2020" = rast("C:/Users/Andres/OneDrive - University of Saskatchewan/04_landcover/05_Simplification/Canada/can_simp_20.tif"),
  "2021" = rast("C:/Users/Andres/OneDrive - University of Saskatchewan/04_landcover/05_Simplification/Canada/can_simp_21.tif"),
  "2022" = rast("C:/Users/Andres/OneDrive - University of Saskatchewan/04_landcover/05_Simplification/Canada/can_simp_22.tif")
)


```


label classifications
```{r}
simp_classes <- data.frame(
  class = 0:2,
  label = c("IR", "Semi_nat", "Ag"),
  stringsAsFactors = FALSE)

simp_classes
```

Run landscape metrics
```{r}
lsm_simp <- list()

# Loop through each year in the raster list
for (year in names(can_simp_rasters)) {
  for (i in seq_len(nrow(phjv_buff))) {
    buffer_i <- st_transform(phjv_buff[i, ], crs = crs(can_simp_rasters[[year]]))
    
    # Crop and mask the landcover raster for the current year
    metrics <- crop(can_simp_rasters[[year]], buffer_i) |> 
      mask(buffer_i) |> 
      # Calculate landscape metrics
      calculate_lsm(level = "class", metric = c("pland")) |> 
      # Add variables to uniquely identify each point and year
      mutate(srd_id = buffer_i$srd_id, year = as.integer(year)) |> 
      dplyr::select(year, srd_id, class, metric, value)
    
    # Store the result in the list
    lsm_simp[[paste(year, i, sep = "_")]] <- metrics
  }
}

# Combine results into a single data frame
lsm_simp <- bind_rows(lsm_simp)

# View the combined results
print(lsm_simp)

```


```{r}

# Updated code to transform to wide format
phjv_lsm_simp <- lsm_simp |> 
  # Fill missing combinations with zeros
  complete(
    year,                        # Include all years
    srd_id,                      # Ensure all buffers are represented
    class = unique(simp_classes$class), # Ensure all classes are included
    metric = c("pland"), # Include all metrics
    fill = list(value = 0)       # Fill missing values with zeros
  ) |> 
  # Join with descriptive class labels
  left_join(dplyr::select(simp_classes, class, label), by = "class") |> 
  # Transform to wide format
  pivot_wider(
    values_from = value,                          # Metric values to populate wide-format table
    names_from = c(class, label, metric),   # Columns formed by year, class, label, and metric
    names_glue = "{metric}_c{str_pad(class, 2, pad = '0')}_{label}", # Format names
    names_sort = TRUE,                            # Ensure logical sorting of columns
    values_fill = 0                               # Fill missing combinations with zeros
  ) |> 
  arrange(srd_id)                           # Sort rows by year and buffer ID

```



## Add ebird data to phjv_lsm_comp and phjv_lsm_simp data frames
```{r}
# Temporarily drop geometry for the join
phjv_buff <- st_drop_geometry(phjv_buff)  

#remove unnessecary columns
phjv_buff <- phjv_buff[, -c(1:6, 16:23)]

```


Pivot phjv_buff to long for easier rbind
```{r}
phjv_long <- phjv_buff %>%
  pivot_longer(
    cols = starts_with("20"), # Select columns that start with 'abd_20'
    names_to = "year",            # Name of the new column for years
    values_to = "abd"             # Name of the new column for the annual abundance values
  ) %>%
  arrange(srd_id, year)
```



Combine comp and simp landscape metric cols
```{r}

```












R bind phjv_buff to phjv_lsm to have a final dataset to model
```{r}
phjv_long <- phjv_long %>%
  mutate(
    year = as.integer(year),
    srd_id = as.integer(srd_id)
  )

phjv_lsm <- phjv_lsm %>%
  mutate(
    year = as.integer(year),
    srd_id = as.integer(srd_id)
  )

phjv_lsm_final <- phjv_long %>%
  left_join(phjv_lsm, by = c("srd_id", "year"))

```




# Model trend and abundance as a function of landscape metrics
Calcualte and plot correlation matrix
```{r}
library(ggcorrplot)
library(dplyr)

# List of predictors to include
predictors <- c(
   "lpi_c11_Grassland", "ai_cNA_NA", "cohesion_cNA_NA", "ed_cNA_NA", 
  "pd_cNA_NA", "shdi_cNA_NA", "lpi_c09_Forage", "pland_c01_Cereal"
)

# Filter dataset
filtered_data <- phjv_lsm_final %>%
  dplyr::select(all_of(predictors))

# Compute correlation matrix
cor_matrix <- cor(filtered_data, use = "complete.obs", method = "pearson")

# Visualize the correlation matrix
ggcorrplot(cor_matrix, lab = TRUE, lab_size = 3, colors = c("red", "white", "blue"))
```

Land cover proportions correlation
```{r}
# Select only pland variables
pland_vars <- c(
  "pland_c01_Cereal", "pland_c02_Pulses", "pland_c03_Canola", "pland_c04_Soybean", 
  "pland_c05_Oilseed", "pland_c06_Potatoes", "pland_c07_Berries", 
  "pland_c08_Fruits.and.Vegetables", "pland_c09_Forage", "pland_c10_Other.Ag", 
  "pland_c11_Grassland", "pland_c12_Shrubland", "pland_c13_Wetland", 
  "pland_c14_Forested", "pland_c15_Barren", "pland_c16_Urban", "pland_c17_Water", "lpi_c11_Grassland"
)

# Filter dataset for pland variables
pland_data <- phjv_lsm_final[, pland_vars]

# Compute the correlation matrix
pland_cor <- cor(pland_data, use = "complete.obs", method = "pearson")


# Visualize correlations with pairs plot
pairs(
  pland_data, 
  main = "Pairwise Scatterplots for pland Variables",
  pch = 19,  # Solid circles for points
  cex = 0.5  # Reduce point size for clarity
)
```



# Parallel Coordinate plot 
Subset phjv lsm final to 2022 to visualize with parallel coordinate plot
```{r}

phjv_lsm_22 <- subset(phjv_lsm_final, year == "2022")

```


```{r}
# Subset the data to include the required variables
library(dplyr)
df_subset <- phjv_lsm_22 %>% 
  select(abd, abd_trend, , lpi_c11_Grassland, shdi_cNA_NA, cohesion_cNA_NA, ai_cNA_NA, lpi_c09_Forage, pland_c09_Forage, pland_c01_Cereal )

# Normalize the data (scale to 0-1 for PCP visualization)
df_normalized <- as.data.frame(lapply(df_subset, function(x) (x - min(x)) / (max(x) - min(x))))

```



```{r}
# Install plotly if not installed
if (!requireNamespace("plotly", quietly = TRUE)) {
  install.packages("plotly")
}

library(plotly)

plot_ly(
  type = 'parcoords',
  line = list(
    color = df_normalized$abd_trend,  # Color by trend for better visual distinction
    colorscale = 'Viridis'
  ),
  dimensions = list(
    list(label = "Abundance", values = df_normalized$abd),
    list(label = "Trend", values = df_normalized$abd_trend),
    list(label = "Cereal Proportion", values = df_normalized$pland_c01_Cereal)
    
  )
) %>%
  layout(
    paper_bgcolor = 'rgba(0,0,0,0)',  # Transparent background
    plot_bgcolor = 'rgba(0,0,0,0)'   # Transparent plot area
  )


```

Box plot for groups of trends increasing vs decreasing

```{r}
phjv_lsm_dir <- phjv_lsm_22

phjv_lsm_dir$dir <- NA

phjv_lsm_dir$dir <- ifelse(phjv_lsm_dir$abd_trend >= 0, "Positive", "Negative")

```


box plot
```{r}

library(ggplot2)

# Create the plot
ggplot(phjv_lsm_dir, aes(x = dir, y = pland_c01_Cereal, fill = dir)) +
  geom_boxplot(alpha = 0.7, outlier.shape = NA) +  # Boxplot with semi-transparent fill and no outliers
  geom_jitter(width = 0.2, size = 1, alpha = 0.5, aes(color = dir)) +  # Jittered points for individual observations
  labs(
    title = "Boxplot of Cereal proportions by trend direction",
    x = "Direction (Positive or Negative)",
    y = "pland_c01_Cereal"
  ) +
  theme_minimal() +  # Minimal theme
  theme(
    panel.background = element_rect(fill = "transparent", color = NA),  # Transparent background
    plot.background = element_rect(fill = "transparent", color = NA)
  ) +
  scale_fill_manual(values = c("Negative" = "#FF6666", "Positive" = "#66B3FF")) +  # Custom box colors
  scale_color_manual(values = c("Negative" = "#FF6666", "Positive" = "#66B3FF"))  # Matching jitter colors


```

```{r}
t_test_result <- t.test(pland_c01_Cereal ~ dir, data = phjv_lsm_dir)

# View the result
print(t_test_result)
```
















```{r}
library(lme4)

names(phjv_lsm_final)

cor(phjv_lsm_final[c("shdi_cNA_NA", "ai_cNA_NA", "pd_cNA_NA", "ed_cNA_NA", "cohesion_cNA_NA", "lpi_c11_Grassland" )])
pairs(phjv_lsm_final[c("shdi_cNA_NA", "ai_cNA_NA", "pd_cNA_NA", "ed_cNA_NA", "cohesion_cNA_NA")])

# Model abundance as a function of SHDI and other predictors
model <- lmer(abd_trend ~ shdi_cNA_NA + ai_cNA_NA + cohesion_cNA_NA + lpi_c11_Grassland + (1 | srd_id) + (1 | year), 
              data = phjv_lsm_final)

summary(model)
```

